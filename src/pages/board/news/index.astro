---
import SectionLayout from "../../../layouts/SectionLayout.astro";
import type { MarkdownInstance } from "astro";

const nav = [
  { label: "News", href: "/board/news/" },
  { label: "Gallery", href: "/board/gallery/" },
];

type FM = Record<string, any>;

const toImageUrls = (fm: any): string[] => {
  const out: string[] = [];
  const push = (x: any) => {
    if (typeof x === "string" && x.trim()) out.push(x.trim());
  };
  const readList = (arr: any[]) => {
    for (const it of arr) {
      if (typeof it === "string") push(it);
      else if (it && typeof it === "object") push(it.photo ?? it.image ?? it.src ?? it.url);
    }
  };

  if (Array.isArray(fm?.photos)) readList(fm.photos);
  if (Array.isArray(fm?.images)) readList(fm.images);
  push(fm?.cover);
  push(fm?.thumbnail);
  push(fm?.thumb);

  return Array.from(new Set(out));
};

const modules = import.meta.glob<MarkdownInstance<FM>>("/src/content/board/news/*.md");

const items = await Promise.all(
  Object.entries(modules).map(async ([, loader]) => {
    const entry = await loader();
    const fm = entry.frontmatter ?? {};
    const title = (fm.title ?? "Untitled").toString();
    const dateStr = (fm.date ?? fm.published ?? fm.created ?? "").toString();
    const date = dateStr ? new Date(dateStr) : null;
    const images = toImageUrls(fm);
    return { entry, title, date, images };
  })
);

items.sort((a, b) => {
  const ad = a.date ? a.date.getTime() : 0;
  const bd = b.date ? b.date.getTime() : 0;
  if (ad !== bd) return bd - ad;
  return a.title.localeCompare(b.title);
});

const fmt = (d: Date | null) => (d ? d.toISOString().slice(0, 10) : "");
---

<SectionLayout title="News" sectionLabel="BOARD" navItems={nav} heroSrc="/images/sub-hero.jpg">

  <style is:global>
    {`
      /* ✅ PC에서 최소 2~3열 보장 (auto-fit 대신 고정 컬럼) */
      .quilt{
        width:100%;
        display:grid;
        grid-template-columns: repeat(1, minmax(0, 1fr));
        gap: 12px;
        grid-auto-flow: dense;
        grid-auto-rows: 10px; /* JS ROW와 동일 */
        align-items: start;
      }
      @media (min-width: 720px){
        .quilt{ grid-template-columns: repeat(2, minmax(0, 1fr)); }
      }
      @media (min-width: 1100px){
        .quilt{ grid-template-columns: repeat(3, minmax(0, 1fr)); }
      }

      .q-item{
        display:block;
        border:1px solid #eee;
        border-radius:12px;
        overflow:hidden;
        background:#f3f4f6;
      }
      .q-item img{
        width:100%;
        height:100%;
        object-fit: contain;  /* ✅ 절대 안 잘림 */
        display:block;
      }
    `}
  </style>

  <div style="display:grid; gap:56px; margin-top:18px;">
    {items.map(({ title, date, images, entry }) => {
      const when = fmt(date);
      const { Content } = entry;

      return (
        <section style="padding-bottom:28px; border-bottom:1px solid #eee;">
          <header style="margin-bottom:14px;">
            <h2 style="margin:0; font-size:20px;">{title}</h2>
            {when && <div style="margin-top:6px; color:#6b7280; font-size:14px;">{when}</div>}
          </header>

          {images.length > 0 ? (
            <div class="quilt" data-mode="quilt">
              {images.map((src) => (
                <a class="q-item" href={src} target="_blank" rel="noreferrer">
                  <img src={src} alt="" loading="lazy" decoding="async" />
                </a>
              ))}
            </div>
          ) : (
            <div style="color:#6b7280;">No images.</div>
          )}

          <div style="margin-top:14px; line-height:1.75;">
            <Content />
          </div>
        </section>
      );
    })}

    {items.length === 0 && <p style="color:#6b7280;">No news posts yet.</p>}
  </div>

  <script is:inline>
    // Quilt 콜라주: 비율 기반 자동 배치 + dense로 빈칸 최소화
    // ✅ 세로 사진이 혼자 너무 커지지 않게 MAX_H 낮춤

    const ROW = 10;   // CSS grid-auto-rows와 동일
    const GAP = 12;   // CSS gap과 동일

    const MIN_H = 170;  // 너무 작아지지 않게
    const MAX_H = 360;  // ✅ 너무 커지는 것 방지(여기 더 줄이면 더 컴팩트)

    function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

    async function ensureMeta(img){
      if (img.naturalWidth > 0 && img.naturalHeight > 0) return;
      try { if (img.decode) await img.decode(); } catch(_) {}
      if (img.naturalWidth > 0 && img.naturalHeight > 0) return;
      await new Promise(res => img.addEventListener("load", res, { once:true }));
    }

    function pickColSpan(aspect, idx, cols){
      // 3열 이상일 때만 가끔 2칸짜리(큰 사진) 허용
      if (cols < 3) return 1;
      if (aspect >= 1.55 && (idx % 6 === 0)) return 2;
      if (aspect >= 1.90 && (idx % 4 === 0)) return 2;
      return 1;
    }

    function getCols(container){
      // 현재 grid 컬럼 개수 계산
      const cs = getComputedStyle(container).gridTemplateColumns;
      if (!cs) return 1;
      return cs.split(" ").length;
    }

    function relayout(container){
      const items = Array.from(container.querySelectorAll(".q-item"));
      if (!items.length) return;

      const cols = getCols(container);

      // 1) col-span 결정
      items.forEach((a, idx) => {
        const img = a.querySelector("img");
        const w = img?.naturalWidth || 1;
        const h = img?.naturalHeight || 1;
        const aspect = w / h;

        const colSpan = pickColSpan(aspect, idx, cols);
        a.style.gridColumnEnd = `span ${colSpan}`;
      });

      // 2) width 확정 후 row-span 계산
      requestAnimationFrame(() => {
        items.forEach((a) => {
          const img = a.querySelector("img");
          const w0 = img?.naturalWidth || 1;
          const h0 = img?.naturalHeight || 1;
          const aspect = w0 / h0;

          const width = a.getBoundingClientRect().width;
          let h = width / aspect;        // 비율 유지
          h = clamp(h, MIN_H, MAX_H);    // ✅ 과하게 커지는 것 차단

          const rowSpan = Math.ceil((h + GAP) / ROW);
          a.style.gridRowEnd = `span ${rowSpan}`;
        });
      });
    }

    async function layoutAll(){
      const containers = Array.from(document.querySelectorAll(".quilt[data-mode='quilt']"));
      for (const c of containers){
        const imgs = Array.from(c.querySelectorAll("img"));
        await Promise.all(imgs.map(ensureMeta));
        relayout(c);
      }
    }

    let t = null;
    window.addEventListener("resize", () => {
      clearTimeout(t);
      t = setTimeout(layoutAll, 150);
    });

    layoutAll();
  </script>
</SectionLayout>
